#!/bin/bash
# shellcheck disable=2015
#
# hardph — hardening command-line tool for Pi-hole
#
# Usage:
#   The script applies allowlist desktop firewall rules from its config file. The
#   default config filepath is "$HOME", but can be specified with '--config-path='
#   option.
#   It supports firewalld and UFW, can apply rules directly with '--restrict' option,
#   can reset the firewall and apply rules recommended by Pi-hole, and display the
#   system's general networking information.
#   It assumes a GNU/Linux system with default firewall settings, hence it is recommended
#   to do a '--reset' before applying rules.
# Rationale:
#   Many Pi-hole users run with their router's DNS port forwarded by misconfiguration,
#   thus opened on the internet. Additionally, configuring firewall rules manually can
#   be cumbersome.
# Caveat:
#   The logic and rules behind the script is simple, so advanced users may not find
#   it much useful, depending on their networking setup.
# Sources:
#   https://docs.pi-hole.net/main/prerequisites/#firewalls
#   https://reddit.com/r/pihole/comments/x7wns0/pihole_hardening_tips_4fun
#
# TODO:
#   - Rewrite the script in Unix/GNU style
#   - Replace noisy prompts and interactivity with options
#   - Add config file
#   - Add makefile
#   - Add man page
#   - Remove the usage, rationale, etc comments above and add them to the man page
#   - Add bash completion
#   - Add unit testing
#   - Add the source files to a dir tree structure for organization
#   - Rewrite the README
#   - Add INSTALL file
#   - Add changelog, new features, and PGP sig on Github releases
#   - Add automated unit tests with Github workflows

shopt -s extglob

prog=${0##*/}
cfgname=.${prog}.cfg
version='2.0'

show_help() {
cat << END
Usage: $prog [OPTION]...
  or:  $prog [OPTION]... -r MODE IP[,IP] ...
Hardening command-line tool for Pi-hole.
Apply allowlist desktop firewall rules from its config file.

With no --config-path= OPTION, set PATH to the user's home directory.
With the --restrict= OPTION, do not parse the config file.

Options:
  -d, --delete=MODE IP   delete IP address of MODE
  -h, --help             display this help and exit
  -i, --info             output all MODEs status information and exit
  -n, --dry-run          print firewall commands without execution
  -q, --quiet            show no output
  -r, --restrict=MODE IP restrict MODE by IP address
  -R, --reset            reset firewall and apply the recommended Pi-hole rules
  -v, --version          output version information and exit
  -V, --verbose          more output verbosity
      --config-path=PATH set PATH of config file

Firewalls:
  firewalld, UFW

MODEs:
  pihole, ssh, web

IPs:
  Valid allowed IPs must be IPv4 and comma delimited.

Example:
  $ $prog -r pihole 192.168.0.0/24 -r web 192.168.0.3,192.168.0.7
    allow only the 192.168.0.1–254 range of IPs to access Pi-hole, also
    only the 192.168.0.3 and 192.168.0.7 IPs to access web interface.
END

exit 0
}

show_version() { printf '%s\n' "$prog $version"; exit 0; }

die() {
  local status err

  case $1 in
    [0-9]*) status=$1; shift ;;
    *) status=1
  esac
  err="${prog}: $1"; shift

  printf '%s\n' "$err" "$@" >&$(( 1 + (status != 0) ))
  exit "$status"
}

is_installed() { command -v "$@" > /dev/null 2>&1; }

is_connected() { timeout 1 bash -c '> /dev/tcp/1.1.1.1/53' 2> /dev/null; }

printfmt() { printf '  %s\n' "$@"; }

errfmt() { printf '%s\n' "$prog: $* not installed (status output will break)" >&2; }

check_cfgpath() {
  expand_tilde=${1/~'/'/$HOME/}
  [[ ! -d $expand_tilde ]] && die "nonexistent '$1' path"
}

parse_cfgfile() {
  local filepath expand_tilde line mode

  filepath=${CFGPATH:-$HOME}
  check_cfgpath "$filepath"

  if [[ ! -s $expand_tilde/$cfgname ]]; then
    die "nonexistent or empty '$cfgname' config file"
  fi

  while read -r line; do
    : \$line: "$line"
    case $line in
      @(pihole|ssh|web)_ips=\()
        mode=${line%_*}
        ;;
      \))
        unset mode
        ;;
      !(\#*|''))
        : \$mode: "$mode"
        case $mode in
          pihole|ssh|web)
            declare -n mode_ips=${mode}_ips
            mode_ips+=("$line")
        esac
    esac
    continue
  done < "$expand_tilde/$cfgname"

  : 'pihole_ips=('"${pihole_ips[*]}"')'
  : 'ssh_ips=('"${ssh_ips[*]}"')'
  : 'web_ips=('"${web_ips[*]}"')'
}

fwfmt() {
  ((!delete)) \
    && printf '%s\n' "Allowing $ip IP to access the $1 $2..." \
    || printf '%s\n' "Removing allowed $ip IP from $1 $2..."
}

reload_firewall() {
  local err="failed to reload $firewall"

  printf '%s\n' "Reloading $firewall..."

  case $firewall in
    firewalld) $print sudo firewall-cmd --reload >&$((1 + fd)) || die "$err" ;;
    ufw) $print sudo ufw reload >&$((1 + fd)) || die "$err" ;;
  esac

  printf '%s\n' 'OK'
}

# shellcheck disable=2086
apply_fwd_rules() {
  local ip

  for ip in "${mode_ips[@]}"; do
    fwfmt "$service" 'service'

    $print sudo firewall-cmd --permanent --${cmd:-add}-rich-rule="rule family=ipv4 \
      source address=$ip service name=$service accept" >&$((1 + fd)) || die "$err"
  done
}

del_fwd_services() {
  if ((!delete)) && sudo firewall-cmd --zone=public --query-service="$service" > /dev/null; then
    printf '%s\n' "Removing $service service..."

    $print sudo firewall-cmd --permanent --remove-service="$service" >&$((1 + fd)) || die "$err"
  fi
}

parse_firewalld() {
  local service err

  service=$1
  err='failed to apply firewalld rule'

  printf '%s\n' 'Applying firewalld rules...'

  del_fwd_services
  apply_fwd_rules

  printf '%s\n' 'OK'
}

# shellcheck disable=2086
apply_ufw_rules() {
  local ip

  for ip in "${mode_ips[@]}"; do
    fwfmt "$port" 'port'

    case $portnr in
      53)
        {
          $print sudo ufw $cmd allow proto tcp from "$ip" to any port 53
          $print sudo ufw $cmd allow proto udp from "$ip" to any port 53
        } >&$((1 + fd)) || die "$err"
        ;;
      22|80)
        $print sudo ufw $cmd allow proto tcp from "$ip" to any port "$portnr" >&$((1 + fd)) || die "$err"
    esac
  done
}

del_ufw_ports() {
  if ((!delete)) && [[ -n ${service_status[*]} ]]; then
    printf '%s\n' "Removing $port port rules..."

    case $portnr in
      53) { $print sudo ufw delete allow 53/tcp && $print sudo ufw delete allow 53/udp; } >&$((1 + fd)) || die "$err" ;;
      22|80) $print sudo ufw delete allow "$portnr"/tcp >&$((1 + fd)) || die "$err"
    esac
  fi
}

parse_ufw() {
  local portnr service_status err port

  portnr=$1
  service_status=$(sudo ufw status | awk -v var="^${portnr}/" '$1 ~ var && $3 == "Anywhere"')
  err='failed to apply ufw rule'

  case $portnr in
    22) port='SSH' ;;
    53) port='DNS' ;;
    80) port='HTTP'
  esac

  printf '%s\n' 'Applying ufw rules...'

  del_ufw_ports
  apply_ufw_rules

  printf '%s\n' 'OK'
}

parse_rules() {
  local mode_ips

  declare -n mode_ips=${mode}_ips
  parse=1

  case $mode in
    pihole)
      case $firewall in
        firewalld) parse_firewalld dns ;;
        ufw) parse_ufw 53
      esac
      ;;
    ssh)
      case $firewall in
        firewalld) parse_firewalld ssh ;;
        ufw) parse_ufw 22
      esac
      ;;
    web)
      case $firewall in
        firewalld) parse_firewalld http ;;
        ufw) parse_ufw 80
      esac
  esac
}

check_delete() {
  if ((delete)); then
    case $firewall in
      firewalld) cmd='remove' ;;
      ufw) cmd='delete'
    esac
  fi
}

validate_ip() {
  local invalid_ips range cidr ip_regex ip

  invalid_ips=()
  range='[1-9]?[0-9]|1[0-9][0-9]|25[0-5]|2[0-4][0-9]'
  cidr='[0-9]|1[0-9]|2[0-9]|3[0-2]'
  ip_regex="^(($range)\.){3}($range)(\/?(($cidr)?))$"

  printf '%s\n' "Validating $mode IPs..."

  for ip in "${mode_ips[@]}"; do
    [[ $ip =~ $ip_regex ]] || invalid_ips+=("$ip")
  done

  if [[ -n ${invalid_ips[*]} ]]; then
    die \
      'failed to validate IPs' \
      "Invalid $mode IPs:" \
      "$(printfmt "${invalid_ips[@]}")" \
      "$errhelp for a valid input."
  fi

  printf '%s\n' 'OK'
}

parse_ips() {
  local mode mode_ips cmd parse

  for mode in pihole ssh web; do
    declare -n mode_ips=${mode}_ips

    if [[ -n ${mode_ips[*]} ]]; then
      validate_ip
      check_delete
      parse_rules
    fi
  done

  if ((!parse)); then
    die 0 'no IPs were found to be parsed'
  fi

  reload_firewall
}

reset_rules() {
  local err="failed to reset $firewall rule"

  printf '%s\n' "Resetting $firewall and applying Pi-holes's recommended rules..."

  case $firewall in
    firewalld)
      $print sudo bash -c 'rm -rf /etc/firewalld/zones/*' >&$((1 + fd)) || exit 1
      {
        $print sudo firewall-cmd --complete-reload \
          && $print sudo firewall-cmd --permanent --add-service=http --add-service=dns --add-service=dhcp \
          && $print sudo firewall-cmd --permanent --new-zone=ftl \
          && $print sudo firewall-cmd --permanent --zone=ftl --add-interface=lo \
          && $print sudo firewall-cmd --permanent --zone=ftl --add-port=4711/tcp \
          && $print sudo firewall-cmd --reload
      } >&$((1 + fd)) || die "$err"
      ;;
    ufw)
      {
        $print sudo ufw --force reset \
          && $print sudo ufw enable \
          && $print sudo ufw allow 80/tcp \
          && $print sudo ufw allow 53/tcp \
          && $print sudo ufw allow 53/udp \
          && $print sudo ufw allow 67/tcp \
          && $print sudo ufw allow 67/udp \
          && $print sudo ufw reload
      } >&$((1 + fd)) || die "$err"
  esac

  printf '%s\n' 'OK'
  exit 0
}

get_fw_rules() {
  local fw cmd cmd_arr

  case $firewall in
    firewalld)
      fw=${firewall^}
      cmd=(sudo firewall-cmd --zone=public --list-all)
      ;;
    ufw)
      fw=${firewall^^}
      cmd=(sudo ufw status verbose)
  esac

  readarray -t cmd_arr < <(printf '%s\n' "$("${cmd[@]}")")

  printf '%s\n' "$fw"
  printfmt "${cmd_arr[@]}"
}

server_status() {
  local port target service

  case $1 in
    ssh) port=22 target='SSH' ;;
    web) port=80 target='Web'
  esac

  service=$(
    sudo ss \
      --numeric \
      --tcp \
      --listening \
      --processes \
      --ipv4 \
      | awk -v var=":${port}$" '$4 ~ var {split($6, str, /"/); print str[2]}'
    )

  printf '%s\n' "$target server"

  if [[ -n $service ]]; then
    printfmt "$service server: OK"
    service_status "$service"
  else
    printfmt 'server: not detected' ''
  fi
}

service_status() {
  local service status activity

  case $1 in
    sshd) service=${1%d} ;;
    *) service=$1
  esac

  status=$(systemctl is-enabled "$service")
  activity=$(systemctl is-active "$service")

  printfmt "service: $status and $activity" ''
}

firewall_status() {
  local status

  case $firewall in
    firewalld) status=$(sudo firewall-cmd --state) ;;
    ufw) status=$(sudo ufw status verbose | awk '/Status/ {print $2}')
  esac

  printf '%s\n' 'Firewall'
  printfmt \
    "$firewall install: OK" \
    "status: $status"

  service_status "$firewall"
}

pihole_status() {
  local status blocking

  status=$(sudo pihole status | grep -E 'DNS|FTL')
  blocking=$(sudo pihole status | awk '/Pi-hole/ {print $5}')

  printf '%s\n' 'Pi-hole'
  printfmt \
    'pi-hole install: OK' \
    "status: ${status#*] }" \
    "blocking: $blocking"

  service_status pihole-FTL
}

get_dns() {
  if systemctl -q is-enabled systemd-resolved; then
    dns=$(awk '/nameserver/ {print $2; exit}' /run/systemd/resolve/resolv.conf)
  else
    dns=$(dig +noall +stats 1.1.1.1 | awk -F'[()]' '/SERVER/ {print $2}')
  fi
}

get_method() {
  if ip -o -4 addr show "$device" | grep -q dynamic; then
    method='DHCP'
  else
    method='static'
  fi
}

get_type() {
  linktype=$(ip -details link show "$device" | awk '!/altname/ && NR==3 {print $1}')

  if [[ -z $linktype ]]; then
    grep -q "$device" /proc/net/wireless && linktype='wireless'
  fi

  while IFS= read -r line; do
    [[ $line = "$device" ]] && devtype='physical'
  done < <(find /sys/class/net -mindepth 1 -maxdepth 1 ! -lname '*virtual*' -printf '%f\n')
}

get_net_info() {
  read -r _ _ gateway _ device _ lanip _ < <(ip -o -4 route get 1.0.0.0)

  mac=$(< "/sys/class/net/$device/address")
  route=$(ip -oneline -4 route show dev "$device" proto kernel scope link | awk '{print $1}')
  wanip=$(dig +short TXT whoami.ds.akahelp.net | awk -F'"' '{print $4}')
}

network_status() {
  local device linktype devtype mac route gateway method lanip wanip dns

  if is_connected; then
    get_net_info
    get_type
    get_method
    get_dns

    printf '%s\n' 'Network' \
      "$(
          printfmt \
            'status: connected' \
            "interface: $device" \
            "type: ${linktype:-ethernet} [${devtype:-virtual}]" \
            "MAC: $mac" \
            "route: $route" \
            "gateway: $gateway" \
            "private IP: $lanip [$method]" \
            "public IP: $wanip" \
            "primary DNS: $dns" \
            ''
        )"
  else
    printfmt 'status: disconnected' ''
  fi
}

show_info() {
  printf '%s\n' 'Checking status information...'

  {
    network_status
    pihole_status
    firewall_status
    server_status web
    server_status ssh
    get_fw_rules
  } >&3

  printf '%s\n' 'OK'
  exit 0
}

set_fw_vars() {
  local i

  for i in "${installed[@]}"; do
    case $i in
      firewall-cmd) firewall='firewalld' ;;
      ufw) firewall='ufw'
    esac
  done
}

check_fw_activity() {
  local firewalld ufw

  firewalld=${installed[0]%-*}d
  ufw=${installed[1]}

  if systemctl is-active "$firewalld" && systemctl is-active "$ufw"; then
    die 'firewalld and ufw are active'
  fi
}

check_firewalls() {
  local installed i
  installed=()

  printf '%s\n' 'Checking firewalls...'

  for i in "${firewalls[@]}"; do
    is_installed "$i" && installed+=("$i")
  done

  case ${#installed[@]} in
    0) die 'firewalld and ufw are not installed' ;;
    2) check_fw_activity > /dev/null
  esac

  set_fw_vars

  printf '%s\n' 'OK'
}

optionals_fmt() {
  local str item tmp

  case ${#optionals[@]} in
    1)
      errfmt "${optionals[*]} is"
      ;;
    2)
      str=${optionals[*]/%/ and}
      errfmt "${str% and} are"
      ;;
    *)
      item=${optionals[-2]}
      tmp=${optionals[*]/%/,}
      str=${tmp/${item},/${item} and}

      errfmt "${str%,} are"
  esac
}

check_depends() {
  local dep

  printf '%s\n' 'Checking dependencies...'

  for dep in "${depends[@]}"; do
    if ! is_installed "$dep"; then
      case $dep in
        sudo|pihole) die "$dep is not installed" ;;
        *) optionals+=("$dep")
      esac
    fi
  done

  printf '%s\n' 'OK'
}

check_install() {
  local depends firewalls optionals

  depends=(
    'sudo'
    #'pihole'
    'systemctl'
    'timeout'
    'ip'
    'ss'
    'dig'
    'awk'
    'grep'
    'find'
  )
  firewalls=(
    'firewall-cmd'
    'ufw'
  )
  optionals=()

  check_depends
  [[ -n ${optionals[*]} ]] && optionals_fmt
  check_firewalls
}

parse_args() {
  local mode err ips

  mode=$1
  err="missing $mode IPs"
  declare -n mode_ips=${mode}_ips

  : \$@: "$@"
  case $mode in
    '') die 'missing mode argument' ;;
    !(pihole|ssh|web)) die "invalid '$mode' mode" "$errhelp for valid modes."
  esac
  shift

  [[ -z $1 ]] && die "$err"

  readarray -td',' ips < <(printf '%s' "$1")
  mode_ips+=("${ips[@]}")
  : "${mode}_ips"'=('"${mode_ips[*]}"')'
}

parse_opts() {
  local expand_tilde

  pihole_ips=()
  ssh_ips=()
  web_ips=()
  errhelp="See '$prog --help'"

  while (($#)); do
    : \$@: "$@"
    : \$1: "$1"
    case $1 in
      -d|--d?(e?(l?(e?(t?(e)))))) delete=1; shift; parse_args "$1" "$2" ; shift ;;
      -h|--h?(e?(l?(p)))) show_help ;;
      -i|--i?(n?(f?(o)))) info=1 ;;
      -n|--d?(r?(y?(-?(r?(u?(n))))))) dry=1 ;;
      -q|--q?(u?(i?(e?(t))))) quiet=1 ;;
      --r?(e?(s))) die "ambiguous '$1' option ('--restrict', '--reset')" ;;
      -r|--res?(t?(r?(i?(c?(t)))))) restrict=1; shift; parse_args "$1" "$2"; shift ;;
      -R|--res?(e?(t))) reset=1 ;;
      --v?(e?(r))) die "ambiguous '$1' option ('--version', '--verbose')" ;;
      -v|--ver?(s?(i?(o?(n))))) show_version ;;
      -V|--ver?(b?(o?(s?(e))))) verbose=1 ;;
      --c?(o?(n?(f?(i?(g?(-?(p?(a?(t?(h)))))))))))
        shift; CFGPATH=$1; [[ -z $CFGPATH ]] && die 'missing path argument' || check_cfgpath "$CFGPATH" ;;
      --) break ;;
      *) die "invalid '$1' option" "$errhelp for valid options."
    esac
    shift
  done
}

preprocess_opts() {
  local touch touch_opts arg i argc x

  argv=()
  end_opts=
  touch=
  touch_opts='d|r'

  while (($#)); do
    arg=$1; shift

    : \$1: "${end_opts}$arg"
    case ${end_opts}$arg in
      --) ((!touch)) && end_opts=1; touch=; argv+=("$arg") ;;
      --*=*) x=${arg#*=} argv+=("${arg%%=*}" ${x:+"$x"}) ;;
      --*|-) argv+=("$arg") ;;
      -*)
        for ((i=2; i <= ${#arg}; i++)); do
          argc=${arg:i-1:1}
          x=${arg#*"$argc"}
          [[ $argc != -* ]] && argc=-$argc

          : \$argc: "$argc"
          case $argc in
            -@($touch_opts))
              [[ -z $x && -n $1 ]] && { argv+=("$argc" "$1"); shift; } || argv+=("$argc" ${x:+"$x"})
              [[ -z $x && $1 = '--' ]] && touch=1
              break
              ;;
            *)
              argv+=("$argc")
          esac
        done
        ;;
      *) argv+=("$arg")
    esac
  done
}

preprocess_opts "$@"
: 'set preprocessed options & args'
set -- "${argv[@]}"

parse_opts "$@"
set --

: 'pos. params='"$*"
: 'pihole_ips=('"${pihole_ips[*]}"')'
: 'ssh_ips=('"${ssh_ips[*]}"')'
: 'web_ips=('"${web_ips[*]}"')'
: 'CFGPATH='"$CFGPATH"
: 'delete='"$delete"
: 'info='"$info"
: 'dry='"$dry"
: 'quiet='"$quiet"
: 'restrict='"$restrict"
: 'reset='"$reset"
: 'verbose='"$verbose"
: 'end_opts='"$end_opts"

exec 3>&1
((quiet)) && { exec 3>&-; exec > /dev/null 2>&1; }
((!verbose)) && exec > /dev/null

check_install
((info)) && show_info
((dry)) && print='echo' fd=2
((reset)) && reset_rules
((delete && restrict)) && die "mixed '--delete=' and '--restrict=' options"
((delete || restrict)) && { parse_ips; exit $?; }
parse_cfgfile && parse_ips
