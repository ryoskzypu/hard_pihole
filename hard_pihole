#!/bin/bash
# shellcheck disable=2015,2034
#
# hard_pihole
#
# Pi-hole hardening command-line tool.
#
# Usage:
#   This script applies allowlist desktop firewall rules from its config file. The
#   default config filepath is "$HOME", but can be specified with '--config-path='
#   option.
#   It supports Firewalld and UFW, can apply rules directly with '--restrict' option,
#   can reset the firewall and apply rules recommended by Pi-hole, and display
#   the system's general networking information.
#   The script assumes a GNU/Linux system with default firewall settings, hence it
#   is recommended to do a '--reset' before applying rules.
# Rationale:
#   Many Pi-hole users run with their router's DNS port forwarded by misconfiguration,
#   thus opened on the internet. Additionally, configuring firewall rules manually can
#   be cumbersome.
# Caveat:
#   The logic and rules behind this script is simple, so advanced users may not find
#   this much useful, depending on their networking setup.
# Sources:
#   https://docs.pi-hole.net/main/prerequisites/#firewalls
#   https://reddit.com/r/pihole/comments/x7wns0/pihole_hardening_tips_4fun
#
# TODO:
#   - Rewrite the script in Unix/GNU style
#   - Replace noisy prompts and interactivity with options
#   - Add config file
#   - Add bash completion
#   - Add man page
#   - Add makefile
#   - Add new features and PGP sig on github releases
#   - Add unit testing
#   - Add automated unit tests with github workflows
#   - Rewrite README

shopt -s extglob

prog=${0##*/}
cfgname=.${prog}.cfg
version='2.0'

show_help() {
cat << END
Usage: $prog [OPTION]...
  or:  $prog -r MODE IP...
Pi-hole hardening command-line tool.
Apply allowlist desktop firewall rules from its config file.

With no OPTION, load the default ~/$cfgname file.

Options:
      --config-path=PATH  set PATH of config file
  -h, --help              display this help and exit
  -i, --info              output all MODEs status information and exit
  -n, --dry-run           print firewall commands without execution
  -q, --quiet             show no output
  -r, --restrict=MODE IP  restrict MODE by IP address
  -R, --reset             reset firewall and apply the recommended Pi-hole rules
  -v, --version           output version information and exit
  -V, --verbose           more output verbosity

Firewalls:
  firewalld, UFW

MODEs:
  pihole, ssh, web

IPs:
  Valid allowed IPs must be IPv4 and separated by spaces.

Example:
  $ $prog -r pihole 192.168.0.0/24 -r web 192.168.0.3 192.168.0.7
    allow only the 192.168.0.1â€“254 range of IPs to access Pi-hole, also
    only the 192.168.0.3 and 192.168.0.7 IPs to access web interface.
END
}

die() {
  local status err

  case $1 in
    [0-9]*) status=$1; shift ;;
    *) status=1; err='ERROR: '
  esac

  printf '%s\n' "${err}$*" >&$(( 1 + (status != 0) ))
  exit "$status"
}

is_installed() { command -v "$@" > /dev/null 2>&1; }

is_connected() { timeout 1 bash -c '> /dev/tcp/1.1.1.1/53' 2> /dev/null; }

printfmt() { printf '  %s\n' "$@"; }

errfmt() { printf '%s\n' "INFO: $* not installed (status output will break)" >&2; }

parse_cfgfile() {
  local filepath expand_tilde line mode

  filepath=${cfgpath:-$HOME}
  expand_tilde=${filepath/~'/'/$HOME/}

  if [[ ! -s $expand_tilde/$cfgname ]]; then
    die "nonexistent or empty '$cfgname' config file"
  fi

  while read -r line; do
    case $line in
      @(pihole|ssh|web)_ips=\()
        mode=${line%_*}
        ;;
      \))
        unset mode
        ;;
      !(\#*|''))
        case $mode in
          pihole|ssh|web)
            declare -n mode_ips=${mode}_ips
            mode_ips+=("$line")
        esac
    esac
    continue
  done < "$expand_tilde/$cfgname"
}

reload_firewall() {
  local err="failed to reload $firewall"

  printf '%s\n' "Reloading $firewall..."

  case $firewall in
    firewalld) $print sudo firewall-cmd --reload >&$((1 + fd)) || die "$err" ;;
    ufw) $print sudo ufw reload >&$((1 + fd)) || die "$err" ;;
  esac

  printf '%s\n' 'OK'
}

apply_fwd_rules() {
  local service err ip

  service=$1
  err='failed to apply firewalld rule'

  printf '%s\n' 'Applying firewalld rules...'

  if sudo firewall-cmd --zone=public --query-service="$service" > /dev/null; then
    printf '%s\n' "Removing $service service..."
    $print sudo firewall-cmd --permanent --remove-service="$service" >&$((1 + fd)) || die "$err"
  fi

  for ip in "${mode_ips[@]}"; do
    printf '%s\n' "Allowing $ip IP to access the $service service..."

    $print sudo firewall-cmd --permanent --add-rich-rule="rule family=ipv4 \
      source address=$ip service name=$service accept" >&$((1 + fd)) || die "$err"
  done

  printf '%s\n' 'OK'
}

apply_ufw_rules() {
  local portnr service_status err port ip

  portnr=$1
  service_status=$(sudo ufw status | awk -v var="^${portnr}/" '$1 ~ var && $3 == "Anywhere"')
  err='failed to apply ufw rule'

  case $portnr in
    22) port='SSH' ;;
    53) port='DNS' ;;
    80) port='HTTP'
  esac

  printf '%s\n' 'Applying ufw rules...'

  if [[ -n ${service_status[*]} ]]; then
    printf '%s\n' "Removing $port port rules..."

    case $portnr in
      53) { $print sudo ufw delete allow 53/tcp && $print sudo ufw delete allow 53/udp; } >&$((1 + fd)) || die "$err" ;;
      22|80) $print sudo ufw delete allow "$portnr"/tcp >&$((1 + fd)) || die "$err"
    esac
  fi

  for ip in "${mode_ips[@]}"; do
    printf '%s\n' "Allowing $ip IP to access the $port port..."

    case $portnr in
      53)
        {
          $print sudo ufw allow proto tcp from "$ip" to any port 53
          $print sudo ufw allow proto udp from "$ip" to any port 53
        } >&$((1 + fd)) || die "$err"
        ;;
      22|80)
        $print sudo ufw allow proto tcp from "$ip" to any port "$portnr" >&$((1 + fd)) || die "$err"
    esac
  done

  printf '%s\n' 'OK'
}

parse_rules() {
  local mode_ips

  declare -n mode_ips=${mode}_ips
  parse=1

  case $mode in
    pihole)
      case $firewall in
        firewalld) apply_fwd_rules dns ;;
        ufw) apply_ufw_rules 53
      esac
      ;;
    ssh)
      case $firewall in
        firewalld) apply_fwd_rules ssh ;;
        ufw) apply_ufw_rules 22
      esac
      ;;
    web)
      case $firewall in
        firewalld) apply_fwd_rules http ;;
        ufw) apply_ufw_rules 80
      esac
  esac
}

validate_ip() {
  local invalid_ips range cidr ip_regex ip

  invalid_ips=()

  range='[1-9]?[0-9]|1[0-9][0-9]|25[0-5]|2[0-4][0-9]'
  cidr='[0-9]|1[0-9]|2[0-9]|3[0-2]'
  ip_regex="^(($range)\.){3}($range)(\/?(($cidr)?))$"

  printf '%s\n' "Validating $mode IPs..."

  for ip in "${mode_ips[@]}"; do
    [[ $ip =~ $ip_regex ]] || invalid_ips+=("$ip")
  done

  if [[ -n ${invalid_ips[*]} ]]; then
    {
      printf '%s\n' "Invalid $mode IPs:"
      printfmt "${invalid_ips[@]}"
    } >&2
    die "failed to validate IPs (see --help for a valid input)"
  fi

  printf '%s\n' 'OK'
}

parse_ips() {
  local mode mode_ips parse

  for mode in pihole ssh web; do
    declare -n mode_ips=${mode}_ips

    if [[ -n ${mode_ips[*]} ]]; then
      validate_ip
      parse_rules
    fi
  done

  if ((!parse)); then
    die 0 'No IPs were found to be parsed.'
  fi

  reload_firewall
}

reset_rules() {
  local err="failed to reset $firewall rule"

  printf '%s\n' "Resetting $firewall and applying Pi-holes's recommended rules..."

  case $firewall in
    firewalld)
      $print sudo bash -c 'rm -rf /etc/firewalld/zones/*' >&$((1 + fd)) || exit 1
      {
        $print sudo firewall-cmd --complete-reload \
          && $print sudo firewall-cmd --permanent --add-service=http --add-service=dns --add-service=dhcp \
          && $print sudo firewall-cmd --permanent --new-zone=ftl \
          && $print sudo firewall-cmd --permanent --zone=ftl --add-interface=lo \
          && $print sudo firewall-cmd --permanent --zone=ftl --add-port=4711/tcp \
          && $print sudo firewall-cmd --reload
      } >&$((1 + fd)) || die "$err"
      ;;
    ufw)
      {
        $print sudo ufw --force reset \
          && $print sudo ufw enable \
          && $print sudo ufw allow 80/tcp \
          && $print sudo ufw allow 53/tcp \
          && $print sudo ufw allow 53/udp \
          && $print sudo ufw allow 67/tcp \
          && $print sudo ufw allow 67/udp \
          && $print sudo ufw reload
      } >&$((1 + fd)) || die "$err"
  esac

  printf '%s\n' 'OK'
  exit 0
}

get_fw_rules() {
  local fw cmd cmd_arr

  case $firewall in
    firewalld)
      fw=${firewall^}
      cmd=(sudo firewall-cmd --zone=public --list-all)
      ;;
    ufw)
      fw=${firewall^^}
      cmd=(sudo ufw status verbose)
  esac

  readarray -t cmd_arr < <(printf '%s\n' "$("${cmd[@]}")")

  printf '%s\n' "$fw"
  printfmt "${cmd_arr[@]}"
}

server_status() {
  local port target service

  case $1 in
    ssh) port=22 target='SSH' ;;
    web) port=80 target='Web'
  esac

  service=$(sudo ss -ntlp4 | awk -v var=":${port}$" '$4 ~ var {split($6, str, /"/); print str[2]}')

  printf '%s\n' "$target server"

  if [[ -n $service ]]; then
    printfmt "$service server: OK"
    service_status "$service"
  else
    printfmt "$service server: not detected"
    printf '\n'
  fi
}

service_status() {
  local service status activity

  case $1 in
    sshd) service=${1%d} ;;
    *) service=$1
  esac

  status=$(systemctl is-enabled "$service")
  activity=$(systemctl is-active "$service")

  printfmt "service: $status and $activity"
  printf '\n'
}

firewall_status() {
  local status

  case $firewall in
    firewalld) status=$(sudo firewall-cmd --state) ;;
    ufw) status=$(sudo ufw status verbose | awk '/Status/ {print $2}')
  esac

  printf '%s\n' 'Firewall'
  printfmt "$firewall install: OK"
  printfmt "status: $status"

  service_status "$firewall"
}

pihole_status() {
  local status blocking

  status=$(sudo pihole status | grep -E 'DNS|FTL')
  blocking=$(sudo pihole status | awk '/Pi/ {print $5}')

  printf '%s\n' 'Pi-hole'
  printfmt 'pi-hole install: OK'
  printfmt "status: ${status#*] }"
  printfmt "blocking: $blocking"

  service_status pihole-FTL
}

get_dns() {
  if systemctl -q is-enabled systemd-resolved; then
    dns=$(awk '/nameserver/ {print $2; exit}' /run/systemd/resolve/resolv.conf)
  else
    dns=$(dig +noall +stats 1.1.1.1 | awk -F'[()]' '/SERVER/ {print $2}')
  fi
}

get_method() {
  if ip -o -4 addr show "$device" | grep -q dynamic; then
    method='DHCP'
  else
    method='static'
  fi
}

get_type() {
  linktype=$(ip -details link show "$device" | awk '!/altname/ && NR==3 {print $1}')

  if [[ -z $linktype ]]; then
    grep -q "$device" /proc/net/wireless && linktype='wireless'
  fi

  while IFS= read -r line; do
    [[ $line = "$device" ]] && devtype='physical'
  done < <(find /sys/class/net -mindepth 1 -maxdepth 1 ! -lname '*virtual*' -printf '%f\n')
}

get_net_info() {
  read -r _ _ gateway _ device _ lanip _ < <(ip -o -4 route get 1.0.0.0)

  mac=$(< "/sys/class/net/$device/address")
  route=$(ip -o -4 route show dev "$device" proto kernel scope link | awk '{print $1}')
  wanip=$(dig +short TXT whoami.ds.akahelp.net | awk -F'"' '{print $4}')
}

network_status() {
  local device linktype devtype mac route gateway method lanip wanip dns

  if is_connected; then
    get_net_info
    get_type
    get_method
    get_dns

    printf '%s\n' 'Network'
    printfmt 'status: connected'
    printfmt "interface: $device"
    printfmt "type: ${linktype:-ethernet} [${devtype:-virtual}]"
    printfmt "MAC: $mac"
    printfmt "route: $route"
    printfmt "gateway: $gateway"
    printfmt "private IP: $lanip [$method]"
    printfmt "public IP: $wanip"
    printfmt "primary DNS: $dns"
    printf '\n'
  else
    printfmt 'status: disconnected'
    printf '\n'
  fi
}

show_info() {
  printf '%s\n' 'Checking status information...'

  {
    network_status
    pihole_status
    firewall_status
    server_status web
    server_status ssh
    get_fw_rules
  } >&3

  printf '%s\n' 'OK'
  exit 0
}

set_fw_vars() {
  local i

  for i in "${installed[@]}"; do
    case $i in
      firewall-cmd) firewall='firewalld' ;;
      ufw) firewall='ufw'
    esac
  done
}

check_fw_activity() {
  local firewalld ufw

  firewalld=${installed[0]%-*}d
  ufw=${installed[1]}

  if systemctl is-active "$firewalld" && systemctl is-active "$ufw"; then
    die "$firewalld and $ufw are active"
  fi
}

check_firewalls() {
  local installed i

  installed=()

  printf '%s\n' 'Checking firewalls...'

  for i in "${firewalls[@]}"; do
    is_installed "$i" && installed+=("$i")
  done

  case ${#installed[@]} in
    0) die 'firewalld and ufw are not installed' ;;
    2) check_fw_activity > /dev/null
  esac

  set_fw_vars

  printf '%s\n' 'OK'
}

optionals_fmt() {
  local str item tmp

  case ${#opts[@]} in
    1)
      errfmt "${opts[*]} is"
      ;;
    2)
      str=${opts[*]/%/ and}
      errfmt "${str% and} are"
      ;;
    *)
      item=${opts[-2]}
      tmp=${opts[*]/%/,}
      str=${tmp/${item},/${item} and}

      errfmt "${str%,} are"
  esac
}

check_depends() {
  local dep

  printf '%s\n' 'Checking dependencies...'

  for dep in "${depends[@]}"; do
    if ! is_installed "$dep"; then
      case $dep in
        sudo|pihole) die "$dep is not installed" ;;
        *) opts+=("$dep")
      esac
    fi
  done

  printf '%s\n' 'OK'
}

check_install() {
  local depends firewalls opts

  depends=(
    'sudo'
    #'pihole'
    'systemctl'
    'timeout'
    'ip'
    'ss'
    'dig'
    'awk'
    'grep'
    'find'
  )
  firewalls=(
    'firewall-cmd'
    'ufw'
  )
  opts=()

  check_depends
  [[ -n ${opts[*]} ]] && optionals_fmt
  check_firewalls
}

parse_modes() {
  local err arg
  : \$@: "$@"
  : \$1: "$1"
  : \$mode: "$mode"
  declare -n mode_ips=${mode}_ips
  err="missing $mode IPs"; shift

  [[ -z $1 ]] && die "$err"

  for arg; do
    : \$arg: "$arg"
    if [[ $arg = -* ]]; then
      [[ -z ${mode_ips[*]} ]] && die "$err" || break
    else
       mode_ips+=("$arg"); shift
    fi
  done

  : \$@: "$@"
  : \$1: "$1"
  readarray -t main_args < <(printf '%s\n' "$@")
}

parse_args() {
  local mode expand_tilde

  pihole_ips=()
  ssh_ips=()
  web_ips=()

  while (($#)); do
    : \$@: "$@"
    : \$1: "$1"
    case $1 in
      --help|-h) show_help; exit 0 ;;
      --version|-v) die 0 "$prog $version" ;;
      --info|-i) info=1; shift ;;
      --verbose|-V) verb=1; shift ;;
      --quiet|-q) quiet=1; shift ;;
      --dry-run|-n) dry=1; shift ;;
      --reset|-R) reset=1; shift ;;
      --restrict?(=*)|-r)
        : \$1: "$1"
        restrict=1
        case $1 in
          --*=*) mode=${1#*=} ;;
          -*) shift; mode=$1 ;;
        esac

        : \$mode: "$mode"
        case $mode in
          pihole|ssh|web) parse_modes "$@"; [[ -z ${main_args[*]} ]] && set -- || set -- "${main_args[@]}" ;;
          '') die 'missing MODE' ;;
          *) die 'invalid MODE'
        esac
        ;;
      --config-path?(=*))
        case $1 in
          --*=*) cfgpath=${1#*=}; shift ;;
          --*) shift; cfgpath=$1
        esac

        [[ -z $cfgpath ]] && die 'missing PATH'

        expand_tilde=${cfgpath/~'/'/$HOME/}
        [[ ! -d $expand_tilde ]] && die "nonexistent '$cfgpath' PATH"
        ;;
      --) break ;;
      *) die "invalid '$1' option"
    esac
  done
}

parse_args "$@"
#declare -p pihole_ips
#declare -p ssh_ips
#declare -p web_ips
exec 3>&1
((quiet)) && { exec 3>&-; exec > /dev/null 2>&1; }
((!verb)) && exec > /dev/null

check_install
((info)) && show_info
((dry)) && print='echo' fd=2
((reset)) && reset_rules
((restrict)) && { parse_ips; exit $?; }
parse_cfgfile && parse_ips
