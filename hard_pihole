#!/bin/bash
# shellcheck disable=SC2015
#
# hard_pihole
#
# Hardening command-line tool for Pi-hole.
#
# Usage:
#   This script applies desktop firewall whitelist rules from its config file. The
#   default config filepath is "$HOME", but can be specified with '--config-path='
#   option.
#   It supports Firewalld and UFW, can apply rules directly with '--restrict' option,
#   can reset the firewall and apply rules recommended by Pi-hole, and display
#   the system's general networking information.
#   The script assumes a GNU/Linux system with default firewall settings, hence it
#   is recommended to do a '--reset' before applying rules.
# Rationale:
#   Many Pi-hole users run with their router's DNS port forwarded by misconfiguration,
#   thus opened on the internet. Additionally, configuring firewall rules manually can
#   be cumbersome.
# Caveat:
#   The logic and rules behind this script is simple, so advanced users may not find
#   this much useful, depending on their networking setup.
# Sources:
#   https://docs.pi-hole.net/main/prerequisites/#firewalls
#   https://reddit.com/r/pihole/comments/x7wns0/pihole_hardening_tips_4fun
#
# TODO:
#   - Rewrite the script in Unix/GNU style
#   - Replace noisy prompts and interactivity with options
#   - Add config file
#   - Add bash completion
#   - Add man page
#   - Add makefile
#   - Add new features and PGP sig on github releases
#   - Add unit testing
#   - Add automated unit tests with github workflows
#   - Rewrite README

shopt -s extglob

prog=${0##*/}
usage="usage: $prog [--config-path=] [--help] [--info] [--quiet] [--reset] [--restrict] [--verbose] [--version]"
cfgname=.${prog}.cfg
version='2.0'

show_help() {
cat << END
$usage
With no options, $prog will source the default ~/$cfgname file and run.

Options:
  -h, --help                    display this help and exit
      --config-path=PATH        set path of config file
  -i, --info                    output all MODEs status information and exit
  -q, --quiet                   show no output
  -r, --restrict MODE <IP> ...  restrict MODEs by IP address
  -R, --reset                   reset firewall and apply the recommended Pi-hole rules
  -v, --version                 output version information and exit
  -V, --verbose                 display more verbosity on output

MODEs:
  network, pihole, web, ssh

Valid IPs:
  allowed IPs must be IPv4 and separated by spaces
  e.g., 192.168.0.0/24 192.168.0.137
END
}

die() {
  local status err

  case $1 in
    [0-9]*) status=$1; shift ;;
    *) status=1; err='ERROR: '
  esac

  printf '%s\n' "${err}$*" >&$(( 1 + (status != 0) ))
  exit "$status"
}

is_installed() { command -v "$@" > /dev/null 2>&1; }

is_connected() { timeout 1 bash -c '> /dev/tcp/1.1.1.1/53' 2> /dev/null; }

printfmt() { printf '  %s\n' "$@"; }

errfmt() { printf '%s\n' "INFO: $* not installed (status output will break)" >&2; }

parse_cfgfile() {
  local config_path exp_tilde

  config_path=${cfgpath:-$HOME/$cfgname}
  exp_tilde=${config_path/~'/'/$HOME/}

  if [[ ! -s $exp_tilde ]]; then
    die "nonexistent or empty '$exp_tilde' config file (run 'make' from Makefile dir to see install usage)"
  fi

  # shellcheck source=/dev/null
  source "$exp_tilde"
}

apply_fwd_rules() {
  local service ips err ip

  service=$1; shift
  readarray -t ips < <(printf '%s\n' "$@")
  err='failed to apply firewalld rule'

  printf '%s\n' 'Applying firewalld rules...'

  if sudo firewall-cmd --zone=public --query-service="$service" > /dev/null; then
    sudo firewall-cmd --permanent --remove-service="$service" || die "$err"
  fi

  for ip in "${ips[@]}"; do
    sudo firewall-cmd --permanent --add-rich-rule="rule family=ipv4 \
      source address=$ip service name=$service accept" || die "$err"
  done

  printf '%s\n' 'Reloading firewalld...'
  sudo firewall-cmd --reload || die 'failed to reload firewalld'

  printf '%s\n' 'OK'
}

apply_ufw_rules() {
  local port ips service_status err ip

  port=$1; shift
  readarray -t ips < <(printf '%s\n' "$@")
  service_status=$(sudo ufw status | awk -v var="^${port}/" '$1 ~ var && $3 == "Anywhere"')
  err='failed to apply ufw rule'

  printf '%s\n' 'Applying ufw rules...'

  if [[ -n ${service_status[*]} ]]; then
    case $port in
      53) { sudo ufw delete allow 53/tcp && sudo ufw delete allow 53/udp; } || die "$err" ;;
      22|80) sudo ufw delete allow "$port"/tcp || die "$err"
    esac
  fi

  for ip in "${ips[@]}"; do
    case $port in
      53)
        {
          sudo ufw allow proto tcp from "$ip" to any port 53
          sudo ufw allow proto udp from "$ip" to any port 53
        } || die "$err"
        ;;
      22|80)
        sudo ufw allow proto tcp from "$ip" to any port "$port" || die "$err"
    esac
  done

  printf '%s\n' 'Reloading ufw...'
  sudo ufw reload || die 'failed to reload ufw'

  printf '%s\n' 'OK'
}

parse_rules() {
  case $1 in
    pihole)
      case $firewall in
        firewalld) apply_fwd_rules dns "${pihole_ips[@]}" ;;
        ufw) apply_ufw_rules 53 "${pihole_ips[@]}"
      esac
      ;;
    ssh)
      case $firewall in
        firewalld) apply_fwd_rules ssh "${ssh_ips[@]}" ;;
        ufw) apply_ufw_rules 22 "${ssh_ips[@]}"
      esac
      ;;
    web)
      case $firewall in
        firewalld) apply_fwd_rules http "${web_ips[@]}" ;;
        ufw) apply_ufw_rules 80 "${web_ips[@]}"
      esac
  esac
}

validate_ip() {
  local ip_type ips invalid_ips range cidr ip_regex ip

  ip_type=$1; shift
  readarray -t ips < <(printf '%s\n' "$@")
  invalid_ips=()

  range='[1-9]?[0-9]|1[0-9][0-9]|25[0-5]|2[0-4][0-9]'
  cidr='[0-9]|1[0-9]|2[0-9]|3[0-2]'
  ip_regex="^(($range)\.){3}($range)(\/?(($cidr)?))$"

  printf '%s\n' "Validating $ip_type IPs..."

  for ip in "${ips[@]}"; do
    [[ $ip =~ $ip_regex ]] || invalid_ips+=("$ip")
  done

  if [[ -n ${invalid_ips[*]} ]]; then
    {
      printf '%s\n' 'Invalid IPs:'
      printfmt "${invalid_ips[@]}"
    } >&2
    die "failed to validate IPs (see --help for a valid input)"
  fi

  printf '%s\n' 'OK'
}

parse_ips() {
  local parse

  if [[ -n ${pihole_ips[*]} ]]; then
    parse=1
    validate_ip 'Pi-hole' "${pihole_ips[@]}"
    parse_rules pihole
  fi
  if [[ -n ${ssh_ips[*]} ]]; then
    parse=1
    validate_ip 'SSH' "${ssh_ips[@]}"
    parse_rules ssh
  fi
  if [[ -n ${web_ips[*]} ]]; then
    parse=1
    validate_ip 'Web interface' "${web_ips[@]}"
    parse_rules web
  fi

  if ((!parse)); then
    die 0 'No IPs were found to be parsed.'
  fi
}

reset_rules() {
  local err="failed to reset $firewall rule"

  printf '%s\n' "Resetting $firewall and applying Pi-holes's recommended rules..."

  case $firewall in
    firewalld)
      sudo bash -c 'rm -rf /etc/firewalld/zones/*' || exit 1
      {
        sudo firewall-cmd --complete-reload \
          && sudo firewall-cmd --permanent --add-service=http --add-service=dns --add-service=dhcp \
          && sudo firewall-cmd --permanent --new-zone=ftl \
          && sudo firewall-cmd --permanent --zone=ftl --add-interface=lo \
          && sudo firewall-cmd --permanent --zone=ftl --add-port=4711/tcp \
          && sudo firewall-cmd --reload
      } || die "$err"
      ;;
    ufw)
      {
        sudo ufw --force reset \
          && sudo ufw enable \
          && sudo ufw allow 80/tcp \
          && sudo ufw allow 53/tcp \
          && sudo ufw allow 53/udp \
          && sudo ufw allow 67/tcp \
          && sudo ufw allow 67/udp \
          && sudo ufw reload
      } || die "$err"
  esac

  printf '%s\n' 'OK'
  exit 0
}

get_fw_rules() {
  local fw cmd cmd_arr

  case $firewall in
    firewalld)
      fw=${firewall^}
      cmd=(sudo firewall-cmd --zone=public --list-all)
      ;;
    ufw)
      fw=${firewall^^}
      cmd=(sudo ufw status verbose)
  esac

  readarray -t cmd_arr < <(printf '%s\n' "$("${cmd[@]}")")

  printf '%s\n' "$fw"
  printf '  %s\n' "${cmd_arr[@]}"
}

server_status() {
  local port target service

  case $1 in
    ssh) port=22 target='SSH' ;;
    web) port=80 target='Web'
  esac

  service=$(sudo ss -ntlp4 | awk -v var=":${port}$" '$4 ~ var {split($6, str, /"/); print str[2]}')

  printf '%s\n' "$target server"

  if [[ -n $service ]]; then
    printfmt "$service server: OK"
    service_status "$service"
  else
    printfmt "$service server: not detected"
    printf '\n'
  fi
}

service_status() {
  local service status activity

  case $1 in
    sshd) service=${1%d} ;;
    *) service=$1
  esac

  status=$(systemctl is-enabled "$service")
  activity=$(systemctl is-active "$service")

  printfmt "service: $status and $activity"
  printf '\n'
}

firewall_status() {
  local status

  case $firewall in
    firewalld) status=$(sudo firewall-cmd --state) ;;
    ufw) status=$(sudo ufw status verbose | awk '/Status/ {print $2}')
  esac

  printf '%s\n' 'Firewall'
  printfmt "$firewall install: OK"
  printfmt "status: $status"

  service_status "${firewall}"
}

pihole_status() {
  local status blocking

  status=$(sudo pihole status | grep -E 'DNS|FTL')
  blocking=$(sudo pihole status | awk '/Pi/ {print $5}')

  printf '%s\n' 'Pi-hole'
  printfmt 'pi-hole install: OK'
  printfmt "status: ${status#*] }"
  printfmt "blocking: $blocking"

  service_status pihole-FTL
}

get_dns() {
  if systemctl -q is-enabled systemd-resolved; then
    dns=$(awk '/nameserver/ {print $2; exit}' /run/systemd/resolve/resolv.conf)
  else
    dns=$(dig +noall +stats 1.1.1.1 | awk -F'[()]' '/SERVER/ {print $2}')
  fi
}

get_method() {
  if ip -o -4 addr show "$device" | grep -q dynamic; then
    method='DHCP'
  else
    method='static'
  fi
}

get_type() {
  linktype=$(ip -details link show "$device" | awk '!/altname/ && NR==3 {print $1}')

  if [[ -z $linktype ]]; then
    grep -q "$device" /proc/net/wireless && linktype='wireless'
  fi

  while IFS= read -r line; do
    [[ $line = "$device" ]] && devtype='physical'
  done < <(find /sys/class/net -mindepth 1 -maxdepth 1 ! -lname '*virtual*' -printf '%f\n')
}

get_net_info() {
  read -r _ _ gateway _ device _ lanip _ < <(ip -o -4 route get 1.0.0.0)

  mac=$(< "/sys/class/net/$device/address")
  route=$(ip -o -4 route show dev "$device" proto kernel scope link | awk '{print $1}')
  wanip=$(dig +short TXT whoami.ds.akahelp.net | awk -F'"' '{print $4}')
}

network_status() {
  local device linktype devtype mac route gateway method lanip wanip dns

  if is_connected; then
    get_net_info
    get_type
    get_method
    get_dns

    printf '%s\n' 'Network'
    printfmt 'status: connected'
    printfmt "interface: $device"
    printfmt "type: ${linktype:-ethernet} [${devtype:-virtual}]"
    printfmt "MAC: $mac"
    printfmt "route: $route"
    printfmt "gateway: $gateway"
    printfmt "private IP: $lanip [$method]"
    printfmt "public IP: $wanip"
    printfmt "primary DNS: $dns"
    printf '\n'
  else
    printfmt 'status: disconnected'
    printf '\n'
  fi
}

show_info() {
  printf '%s\n' 'Checking status information...'

  {
    network_status
    pihole_status
    firewall_status
    server_status web
    server_status ssh
    get_fw_rules
  } >&3

  printf '%s\n' 'OK'
  exit 0
}

set_fw_vars() {
  local i

  for i in "${installed[@]}"; do
    case $i in
      firewall-cmd) firewall='firewalld' ;;
      ufw) firewall='ufw'
    esac
  done
}

check_fw_activity() {
  local firewalld ufw

  firewalld=${installed[0]%-*}d
  ufw=${installed[1]}

  if systemctl is-active "$firewalld" && systemctl is-active "$ufw"; then
    die "$firewalld and $ufw are active"
  fi
}

check_firewalls() {
  local installed i

  installed=()

  printf '%s\n' 'Checking firewalls...'

  for i in "${firewalls[@]}"; do
    is_installed "$i" && installed+=("$i")
  done

  case ${#installed[@]} in
    0) die 'firewalld and ufw are not installed' ;;
    2) check_fw_activity > /dev/null
  esac

  set_fw_vars

  printf '%s\n' 'OK'
}

optionals_fmt() {
  local str item tmp

  case ${#opts[@]} in
    1)
      errfmt "${opts[*]} is"
      ;;
    2)
      str=${opts[*]/%/ and}
      errfmt "${str% and} are"
      ;;
    *)
      item=${opts[-2]}
      tmp=${opts[*]/%/,}
      str=${tmp/${item},/${item} and}

      errfmt "${str%,} are"
  esac
}

check_depends() {
  local dep

  printf '%s\n' 'Checking dependencies...'

  for dep in "${depends[@]}"; do
    if ! is_installed "$dep"; then
      case $dep in
        sudo|pihole) die "$dep is not installed" ;;
        *) opts+=("$dep")
      esac
    fi
  done

  printf '%s\n' 'OK'
}

check_install() {
  local depends firewalls opts

  depends=(
    'sudo'
    #'pihole'
    'systemctl'
    'timeout'
    'ip'
    'ss'
    'dig'
    'awk'
    'grep'
    'find'
  )
  firewalls=(
    'firewall-cmd'
    'ufw'
  )
  opts=()

  check_depends
  [[ -n ${opts[*]} ]] && optionals_fmt
  check_firewalls
}

parse_args() {
  local arg

  pihole_ips=()
  ssh_ips=()
  web_ips=()

  while (($#)); do
    : \$@: "$@"
    : \$1: "$1"
    case $1 in
      --help|-h) show_help; exit 0 ;;
      --version|-v) die 0 "$prog v$version" ;;
      --info|-i) info=1; shift ;;
      --verbose|-V) verb=1; shift ;;
      --quiet|-q) quiet=1; shift ;;
      --reset|-R) reset=1; shift ;;
      --restrict|-r)
        : \$1: "$1"
        restrict=1; shift
        case $1 in
          pihole)
            : \$1: "$1"
            shift
            for arg; do
              : \$arg: "$arg"
              [[ $arg = -* ]] && break || { pihole_ips+=("$arg"); shift; }
            done
            ;;
          ssh)
            shift
            for arg; do
              [[ $arg = -* ]] && break || { ssh_ips+=("$arg"); shift; }
            done
            ;;
          web)
            shift
            for arg; do
              [[ $arg = -* ]] && break || { web_ips+=("$arg"); shift; }
            done
        esac
        ;;
      --config-path=*) cfgpath=${1#*=}; shift ;;
      *) die "invalid '$1' option"
    esac
  done
}

parse_args "$@"
#declare -p pihole_ips
#declare -p ssh_ips
#declare -p web_ips
exec 3>&1
((quiet)) && { exec 3>&-; exec > /dev/null 2>&1; }
((!verb)) && exec > /dev/null

check_install
((info)) && show_info
((reset)) && reset_rules
((restrict)) && { parse_ips; exit $?; }
parse_cfgfile && parse_ips
